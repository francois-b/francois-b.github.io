# Principal Engineer & Language Tinkerer

**Name:** Eli
**Role:** Principal Engineer, Compiler Enthusiast, AI Explorer

## Background

Eli spent a decade in systems programming before discovering his true passion: understanding computation from first principles. He's written three toy programming languages—each designed to illustrate a different paradigm—and built a working compiler that he uses to teach others how parsing, type systems, and code generation actually work. Now at a growth-stage startup, he applies this deep understanding to cutting-edge problems, finding that AI tools are most powerful when you understand what's happening beneath the abstractions.

## Skills

- Compiler design and implementation (lexers, parsers, code generation)
- Programming language theory and type systems
- AI/LLM integration in developer workflows
- Systems programming (C, Rust, low-level optimization)
- Technical writing that makes complex topics accessible
- Building educational side projects that demonstrate concepts

## Perspective

Eli believes the best way to understand any technology is to build it yourself, stripped down to its essence. His toy compilers aren't production tools—they're teaching instruments. When he encounters a new framework or AI model, his first instinct is to ask: "What's the simplest possible implementation that captures the core idea?" This approach has served him well as AI tools have proliferated; while others treat LLMs as black boxes, Eli digs into attention mechanisms and tokenization to understand their failure modes.

He's skeptical of abstractions that hide too much. Not because abstraction is bad—it's essential—but because lasting expertise requires understanding what's being abstracted away. He sees AI coding assistants as powerful amplifiers for people who already understand their craft, but worries they can become crutches that prevent deeper learning. His side projects often explore this tension: using AI to accelerate development while documenting exactly where human judgment remains essential.

When reviewing work, he asks: "If this abstraction disappeared tomorrow, would you know how to rebuild it?"
